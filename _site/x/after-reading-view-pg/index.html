<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>After reading View Programming Guide</title><!--<meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="After reading View Programming Guide" /><meta name="twitter:description" content=" 这两天把 View PG 看了一遍，内容不算多也很基础，不过有些注意点和问题自己以前也困惑过，所以想总结一下。也顺便写了个 demo ，方便理解。"><meta name="description" content=" 这两天把 View PG 看了一遍，内容不算多也很基础，不过有些注意点和问题自己以前也困惑过，所以想总结一下。也顺便写了个 demo ，方便理解。"> --> <!-- highlight.js --><link rel="stylesheet" href="//libs.cncdn.cn/highlight.js/8.4/styles/xcode.min.css"> <script src="//libs.cncdn.cn/highlight.js/8.4/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/x/after-reading-view-pg"><link rel="alternate" type="application/atom+xml" title=".xyz" href="/feed.xml" /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-67913126-2', 'auto'); ga('send', 'pageview'); </script></head><body><main><aside class="logo"> <a href="/x/"></a></aside><noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>After reading View Programming Guide</h1><time>December 27, 2015</time></div><div class="divider"></div><blockquote><p>这两天把<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503-CH1-SW2" target="_blank"> View PG </a> 看了一遍，内容不算多也很基础，不过有些注意点和问题自己以前也困惑过，所以想总结一下。也顺便写了个<a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank"> demo </a>，方便理解。</p></blockquote><h2 id="contentmode">contentMode</h2><p>关于<code>contentMode</code>各个mode间的区别，这张图足以说明 <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p><p><img src="http://i4.tietuku.com/c8148247c644a2d4.png" alt="contentMode" /></p><p>还有个就是<code>UIViewContentModeRedraw</code>，当设置为这个mode时，每一次你改变视图的几何状态时，都会调用<code>drawRect:</code>来响应视图的变化（如果你设置为其他mode的话，<code>drawRect:</code>只会第一次显示的时候调用，之后只会在已经显示的视图内容上进行变化，不会重新绘制视图）。因此设置这个mode的话会导致视图变化响应变慢，所以你应该尽量避免使用这个值，除非你想在你的自定义视图中以自己的方式来拉伸和调整尺寸。</p><p><strong>在写这块 demo 时遇个问题</strong>：<br /> 在 <code>viewDidLoad()</code> 中我想要获取在 Interface Builder 中添加的 ImageView 的frame，但得到的 frame 却和实际显示的不一样，而是在 IB 中显示的frame。后来发现原来调用 <code>viewDidLoad()</code> 时，ImageView 还没有 lay out 完，所以改成在 <code>viewDidAppear()</code> 中获取就没问题了。</p><div class="divider"></div><h2 id="stretchable-views">Stretchable Views</h2><p>文档中提到可以用通过设置<code>contentStretch</code>来使视图 stretchable，只是这个属性在 iOS6.0 的时候就被废除了(-_-!)。不过可以通过 <code>UIImage</code> 的 <code>resizableImageWithCapInsets:</code> 来实现 <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p><pre><code class="language-swift">let image = UIImage(named: "stretchImage")!
let edgeInsets = UIEdgeInsetsMake(30, 30, 30, 30)
imageView.image = image.resizableImageWithCapInsets(edgeInsets, resizingMode: .Stretch)
</code></pre><p>效果如下:<br /> <img src="http://i4.tietuku.com/414739aa5d94043b.png" alt="stretch" /></p><p>你也可以直接在 Asset Catalog 里面选择图片，点击Show Slicing来设置：<br /> <img src="http://i4.tietuku.com/f6a1333ab88cb648.png" alt="asset" /></p><div class="divider"></div><h2 id="frame--bounds--center">Frame &amp; Bounds &amp; Center</h2><p>你可以独立地更改frame，bounds，和 center，但改变其中一个会对其他的造成影响：<br /> - 当你设置了 frame 属性是，bounds 属性内的尺寸值会相应的适配框架矩形的尺寸值。在 center 属性内的值同样改更改适配新的框架矩形的中心点。<br /> - 当你设置了 center 属性，frame 内的原点值跟着改变。<br /> - 当你设置了 bounds 属性的尺寸，在 frame 属性内的尺寸值同样改变适配新的边界矩形的尺寸。</p><p>还有，默认情况下，子视图不会被它的父视图剪切。因此，任何位于父视图的框架外部的子视图都是以其整体呈现。你可以改变这个行为，通过设置父视图的 <code>clipsToBounds</code> 属性为 YES。无论子视图可见部分是否被剪切，触摸事件始终遵从目标的父视图的边界矩形。换句话说，在父视图边界矩形外部的那部分视图发生的触摸事件不会发出给视图。</p><div class="divider"></div><h2 id="transform">Transform</h2><p>UIView的 <code>transform</code> 属性提供了一种简单快速的方式来改变视图，但需要注意的一点就是，如果你对视图进行 transform 操作，那么 <code>frame</code> 属性的值是不可靠的，你只能使用 bounds（不会因为transform而改变） 和 center 来获取视图的尺寸和定位。</p><p>我在<a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank"> demo </a>中写了个例子：比如对 ImageView 进行 rotate 的操作，然后将它的<code>frame</code>赋给 grayView，从下图中就可以看出你得到的 ImageView 的 frame 并不是它实际上的位置信息。</p><p><img src="http://i4.tietuku.com/038c2620cb633262.png" alt="transform" /></p><div class="divider"></div><h2 id="external-display">External Display</h2><p>之前没涉及过这块，就顺便写了个 <a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank"> demo </a> 熟悉一下。</p><p>实现步骤：<br /> 1.add observer:</p><pre><code class="language-swift">let center = NSNotificationCenter.defaultCenter()
center.addObserver(self, selector: "handleScreenConnectNotification:", name: UIScreenDidConnectNotification, object: nil)
center.addObserver(self, selector: "handleScreenDisconnectNotification:", name: UIScreenDidDisconnectNotification, object: nil)

</code></pre><p>2.connect 后的设置：</p><pre><code class="language-swift">func handleScreenConnectNotification(notification: NSNotification) {
    let extScreen = notification.object as! UIScreen
    // no scaling will occur. use overscanCompensationInsets to determine the necessary insets to avoid clipping    
    extScreen.overscanCompensation = .None 
    let screenBounds = extScreen.bounds

    secondWindow = UIWindow(frame: screenBounds)
    secondWindow.screen = extScreen

    // Set the initial UI for the window.

    secondWindow.hidden = false
}

</code></pre><p>你可以通过 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScreenMode_class/index.html#//apple_ref/occ/cl/UIScreenMode" target="_blank"> UIScreenMode </a>来定义了单屏幕模式的属性。可以从它的 <code>availableModes</code> 属性获取屏幕支持的模式的列表并且遍历列表获取的一个来适配你的需求。</p><div class="divider"></div><h2 id="tips-for-using-views-effectively">Tips for Using Views Effectively</h2><ul><li><p>尽量少使用自定义绘制，更多的集成已有的视图控件。比如，UIButton 包含了设置标题和背景图像的方法，不应该再自定义嵌入 UILabel 和 UIImageView</p></li><li><p>尽量不设置视图为透明。设置 <code>opaque</code> 为不透明可以更少的渲染内容，更加的高效。</p></li><li><p>调整你的视图在滚动时的绘制行为。滚动时会导致短时间内产生大量的视图更新，如果你的绘制代码没有适当的应对，视图在滚动时的性能将会迟滞。所以应该考虑在滚动操作开始时更改你的视图行为。例如，你可以暂时降低内容渲染的质量或滚动过程中更改内容模式。当滚动停止后，你可以回到视图之前的状态和按需要更新内容。</p></li></ul><div class="divider"></div><p>上面的代码和例子我都写在一个<a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank"> demo </a>里了，希望对你能有些帮助。</p><div class="footnotes"><ol><li id="fn:1"><p>图片来自: <a href="http://stackoverflow.com/a/24671000" target="_blank">stackoverflow</a> <a href="#fnref:1" class="reversefootnote">&#8617;&#xfe0e;</a></p></li><li id="fn:2"><p>更多用法可以看这篇教程：<a href="http://natashatherobot.com/ios-stretchable-button-uiedgeinsetsmake/" target="_blank">click here!</a> <a href="#fnref:2" class="reversefootnote">&#8617;&#xfe0e;</a></p></li></ol></div></article><div class="back"> <a href="/x/">Back</a></div></main><aside class="note"></aside><script async src="/assets/footnotes.js"></script></body></html>