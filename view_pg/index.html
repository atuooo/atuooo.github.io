<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> After reading View Programming Guide</title><meta name="description" content="After reading View Programming Guide - ooatuoo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://atuo.xyz/atom.xml" title="ooatuoo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/ooatuoo" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/atuooo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">After reading View Programming Guide</h1><div class="post-info">Dec 27, 2015</div><div class="post-content"><p>这两天把 <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html" target="_blank" rel="external">View Programming Guide</a> 看了一遍，内容不算多也很基础，不过有些注意点和问题自己以前也困惑过，所以想总结一下。也顺便写了个 <a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank" rel="external">demo</a>，方便理解。</p>
<h2 id="Frame-amp-Bounds-amp-Center"><a href="#Frame-amp-Bounds-amp-Center" class="headerlink" title="Frame &amp; Bounds &amp; Center"></a>Frame &amp; Bounds &amp; Center</h2><p>你可以独立地更改frame，bounds，和 center，但改变其中一个会对其他的造成影响：</p>
<ul>
<li>当你设置了 frame 属性是，bounds 属性内的尺寸值会相应的适配框架矩形的尺寸值。在 center 属性内的值同样改更改适配新的框架矩形的中心点。</li>
<li>当你设置了 center 属性，frame 内的原点值跟着改变。</li>
<li>当你设置了 bounds 属性的尺寸，在 frame 属性内的尺寸值同样改变适配新的边界矩形的尺寸。</li>
</ul>
<p>还有，默认情况下，子视图不会被它的父视图剪切。因此，任何位于父视图的框架外部的子视图都是以其整体呈现。你可以改变这个行为，通过设置父视图的 <code>clipsToBounds</code> 属性为 YES。无论子视图可见部分是否被剪切，触摸事件始终遵从目标的父视图的边界矩形。换句话说，在父视图边界矩形外部的那部分视图发生的触摸事件不会发出给视图。</p>
<h2 id="contentMode"><a href="#contentMode" class="headerlink" title="contentMode"></a>contentMode</h2><p>关于<code>contentMode</code>各个mode间的区别，这张图足以说明:</p>
<a id="more"></a>
<p><a href="http://stackoverflow.com/a/24671000" target="_blank" rel="external"><img src="http://ogem1is2k.bkt.clouddn.com/static/images/view_pg/content_mode_overview" alt="content_mode_overview"></a></p>
<p>还有个就是<code>UIViewContentModeRedraw</code>，当设置为这个mode时，每一次你改变视图的几何状态时，都会调用<code>drawRect:</code>来响应视图的变化（如果你设置为其他mode的话，<code>drawRect:</code>只会第一次显示的时候调用，之后只会在已经显示的视图内容上进行变化，不会重新绘制视图）。因此设置这个mode的话会导致视图变化响应变慢，所以你应该尽量避免使用这个值，除非你想在你的自定义视图中以自己的方式来拉伸和调整尺寸。</p>
<h2 id="Stretchable-Views"><a href="#Stretchable-Views" class="headerlink" title="Stretchable Views"></a>Stretchable Views</h2><p>文档中提到可以用通过设置<code>contentStretch</code>来使视图 stretchable，只是这个属性在 iOS6.0 的时候就被废除了(-_-!)。不过可以通过 <code>UIImage</code> 的 <code>resizableImageWithCapInsets:</code> 来实现.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"stretchImage"</span>)!</div><div class="line"><span class="keyword">let</span> edgeInsets = <span class="type">UIEdgeInsetsMake</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>)</div><div class="line">imageView.image = image.resizableImageWithCapInsets(edgeInsets, resizingMode: .stretch)</div></pre></td></tr></table></figure>
<p>效果如下:<br><img src="http://ogem1is2k.bkt.clouddn.com/static/images/view_pg/stretchable_demo_ss" alt="stretch_demo"></p>
<p>你也可以直接在 Asset Catalog 里面选择图片，点击Show Slicing来设置：<br><img src="http://ogem1is2k.bkt.clouddn.com/static/images/view_pg/setting_slicing.png" alt="set_slicing"></p>
<p>更详细的设置你可以看下这篇 <a href="http://natashatherobot.com/ios-stretchable-button-uiedgeinsetsmake/" target="_blank" rel="external">文章</a>。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>UIView的 <code>transform</code> 属性提供了一种简单快速的方式来改变视图，但需要注意的一点就是，如果你对视图进行 transform 操作，那么 <code>frame</code> 属性的值是不可靠的，你只能使用 bounds（不会因为transform而改变） 和 center 来获取视图的尺寸和定位。</p>
<p>我在 <a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank" rel="external">demo</a> 中写了个例子：对 imageView 进行 rotate 的操作，然后将它的<code>frame</code>赋给 grayView，从下图中就可以看出你得到的 ImageView 的 frame 并不是它实际上的位置信息。</p>
<p><img src="http://ogem1is2k.bkt.clouddn.com/static/images/view_pg/frame_demo_ss" alt="frame_demo"></p>
<h2 id="External-Display"><a href="#External-Display" class="headerlink" title="External Display"></a>External Display</h2><p>之前没涉及过这块，就顺便写了个 <a href="https://github.com/atuooo/ExampleOfViewPG" target="_blank" rel="external">demo</a> 熟悉一下。</p>
<p>实现步骤：<br>1.add observer:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> defaultCenter = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">defaultCenter.addObserver(<span class="keyword">self</span>, selector: #selector(handleScreenConnectNotification(<span class="number">_</span>:)), name: .<span class="type">UIScreenDidConnect</span>, object: <span class="literal">nil</span>)</div><div class="line">defaultCenter.addObserver(<span class="keyword">self</span>, selector: #selector(handleScreenDisconnectNotification(<span class="number">_</span>:)), name: .<span class="type">UIScreenDidDisconnect</span>, object: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>2.connect 后的设置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleScreenConnectNotification</span><span class="params">(notification: NSNotification)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> extScreen = notification.object <span class="keyword">as</span>! <span class="type">UIScreen</span></div><div class="line">    <span class="comment">// no scaling will occur. use overscanCompensationInsets to determine the necessary insets to avoid clipping    </span></div><div class="line">    extScreen.overscanCompensation = .<span class="keyword">none</span> </div><div class="line">    <span class="keyword">let</span> screenBounds = extScreen.bounds</div><div class="line"></div><div class="line">    secondWindow = <span class="type">UIWindow</span>(frame: screenBounds)</div><div class="line">    secondWindow.screen = extScreen</div><div class="line"></div><div class="line">    <span class="comment">// Set the initial UI for the window.</span></div><div class="line"></div><div class="line">    secondWindow.isHidden = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以通过 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScreenMode_class/index.html#//apple_ref/occ/cl/UIScreenMode" target="_blank" rel="external">UIScreenMode</a> 来定义了单屏幕模式的属性。可以从它的 <code>availableModes</code> 属性获取屏幕支持的模式的列表并且遍历列表获取的一个来适配你的需求。</p>
<h2 id="Tips-for-Using-Views-Effectively"><a href="#Tips-for-Using-Views-Effectively" class="headerlink" title="Tips for Using Views Effectively"></a>Tips for Using Views Effectively</h2><ul>
<li><p>尽量少使用自定义绘制，更多的集成已有的视图控件。比如，UIButton 包含了设置标题和背景图像的方法，不应该再自定义嵌入 UILabel 和 UIImageView</p>
</li>
<li><p>尽量不设置视图为透明。设置 <code>opaque</code> 为不透明可以更少的渲染内容，更加的高效。</p>
</li>
<li><p>调整你的视图在滚动时的绘制行为。滚动时会导致短时间内产生大量的视图更新，如果你的绘制代码没有适当的应对，视图在滚动时的性能将会迟滞。所以应该考虑在滚动操作开始时更改你的视图行为。例如，你可以暂时降低内容渲染的质量或滚动过程中更改内容模式。当滚动停止后，你可以回到视图之前的状态和按需要更新内容。</p>
</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/fetch-gif/" class="prev">PREV</a></div><div data-thread-key="view_pg/" data-title="After reading View Programming Guide" data-url="http://atuo.xyz/view_pg/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"ooatuoo"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://atuo.xyz">ooatuoo</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">apollo_theme</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-67913126-2",'auto');ga('send','pageview');</script></body></html>